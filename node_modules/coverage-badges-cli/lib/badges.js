"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.badge = badge;
const badgen_1 = require("badgen");
const fs_1 = require("fs");
const mini_svg_data_uri_1 = __importDefault(require("mini-svg-data-uri"));
const lodash_get_1 = __importDefault(require("lodash.get"));
const getIconString = (path) => {
    return (0, fs_1.readFileSync)(path, 'utf8');
};
const defaultColorData = {
    '#49c31a': [100],
    '#97c40f': [99.99, 90],
    '#a0a127': [89.99, 80],
    '#cba317': [79.99, 60],
    '#ce0000': [59.99, 0],
};
function badge(option, summary) {
    const _a = (option || {}), { label = 'coverage', style = 'classic', jsonPath = 'total.statements.pct', color: optionColor, arbitrary } = _a, otherOption = __rest(_a, ["label", "style", "jsonPath", "color", "arbitrary"]);
    let pct = summary;
    pct = (0, lodash_get_1.default)(summary, jsonPath, 0);
    if (!arbitrary && !isNaN(Number(pct))) {
        pct = Number(pct);
    }
    if (!arbitrary && typeof pct !== 'number') {
        throw new Error(`${jsonPath} evaluates to ${JSON.stringify(pct)} and is not a suitable path in the JSON coverage data`);
    }
    const colorData = defaultColorData;
    const color = Object.keys(colorData).find((value, idx) => {
        if (colorData[value].length === 1 && pct >= colorData[value][0]) {
            return true;
        }
        if (colorData[value].length === 2 && pct <= colorData[value][0] && pct >= colorData[value][1]) {
            return true;
        }
        return false;
    });
    const suffix = arbitrary ? "" : "%";
    const badgenArgs = Object.assign(Object.assign({}, otherOption), { style,
        label, status: `${pct < 0 ? 'Unknown' : `${pct}${suffix}`}`, color: (color || 'e5e5e5').replace(/^#/, '') });
    if (optionColor) {
        badgenArgs.color = optionColor.replace(/^#/, '');
    }
    if (option.icon) {
        const svgString = getIconString(option.icon);
        const svgDataUri = (0, mini_svg_data_uri_1.default)(svgString);
        badgenArgs.icon = svgDataUri;
    }
    console.log("badgenArgs", badgenArgs);
    return (0, badgen_1.badgen)(badgenArgs);
}
//# sourceMappingURL=badges.js.map